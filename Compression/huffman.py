import operator
import os
import sys
import argparse

class TreeNode:
    '''
    Tree node.

    Args:
        left (chr): Label of the left child of the three node
                    (by defaul None for leaves)

        right (chr): Label of the right child of the three node
                     (by defaul None for leaves)

    Attributes:
        left (chr): Label of the left child of the three node
                    (by defaul None for leaves)

        right (chr): Label of the right child of the three node
                     (by defaul None for leaves)
    '''
    
    def __init__(self, left=None, right=None):
        self.left = left
        self.right = right

def insertion(list_freq, new_label, new_freq):
    '''
    Insert a new node in the list of (label, #occurrences)
    by taking the list ordered by decreasing #occurrences.

    Args:
        list_freq (list): List of tuples (label, #occurrences)

        new_label (chr): Label of the new node

        new_freq (int): Number of occurrences of new_label in the
                        text previously analysed
    '''


    #Insert a new node in the three implementation
    for index in range(0, len(list_freq)):
        (label, freq) = list_freq[index]

        if freq < new_freq:
            list_freq.insert(index, (new_label, new_freq))
            return

    #New frequency in the last element
    list_freq.append((new_label, new_freq))

class HuffmanTree:
    '''
    Huffman encoder/decoder.

    Args:
        freq_dict (dict): Dictionary of (label, #occurrences)
    
    Attributes:
        freq_dict (dict): Dictionary of (label, #occurrences)

        huffman_code (dict): Dictionary with final associations between
                             character and relative Huffman code

        nodes (dict): Dictionary with the couples (k, v), one for each 
                      tree node, where:
                      k: label associate to a tree node
                      v: #occurrences of the label in the text 
    
        root_label (str): Label of the root node 
                          (contiaining all the characters in the text)
    
    '''

    def __init__(self, freq_dict):
        self.freq_dict = dict(sorted(freq_dict.items(),
                                  key=operator.itemgetter(1),
                                  reverse=True))
        
        self.huffman_code = {k:'' for k in list(self.freq_dict.keys())}
        self.nodes = {}
        self.root_label = ''
        self.create_tree(self.freq_dict.copy())

    def create_tree(self, freq_dict):
        '''
        Create the Huffman tree.

        Args:
            freq_dict (dict): Dictionary of (label, #occurrences)
        '''


        list_freq = list(freq_dict.items())
        
        while len(list_freq) > 1:
            (label_L, freq_L) = list_freq[-2]
            (label_R, freq_R) = list_freq[-1]
            #Updated the Huffman codes
            self.update_huffman(label_L, label_R)
            
            left = label_L
            #If the label_L is already in the list
            if label_L in list(self.nodes.keys()):
                #The left child is the node associated
                left = self.nodes[label_L]

            right = label_R
            #If the label_L is already in the list      
            if label_R in list(self.nodes.keys()):
                #The left child is the node associated
                right = self.nodes[label_R]

            #Update list of tuples (label, frequency)            
            list_freq = list_freq[:-2]
            new_freq = freq_L + freq_R
            new_label = label_L + label_R
            self.nodes[new_label]=TreeNode(left, right)
            self.root_label = new_label
            insertion(list_freq, new_label, new_freq)

    def update_huffman(self, label_L, label_R):
        '''
        Update Huffman tree codes.

        Args:
            label_L (str): Label of left child of the new parent

            label_R (str): Label of right child of the new parent
        '''

        #Code for left child
        for x in label_L:
            self.huffman_code[x] = '0'+ self.huffman_code[x]

        #Code for right child
        for x in label_R:
            self.huffman_code[x] = '1'+ self.huffman_code[x]

    def encode(self, text):
        '''
        Encode the text looking to the codes 
        generated by Huffman tree.

        Args:
            text (str): Text to be encoded
        
        Returns:
            encoded_str (str): Encoded text
        '''
        
        encoded_str = ''
        
        #Analyse each character of the text
        for x in text:
            encoded_str += self.huffman_code[x]

        return encoded_str

    def decode(self, text):
        '''
        Decode the text looking to the codes 
        generated by Huffman tree.

        Args:
            text (str): Text to be decoded
        
        Returns:
            encoded_str (str): Decoded text
        '''

        decoded_str = ''
        #Binary search from the root node
        node = self.nodes[self.root_label]
        
        #Analyse each character of the text 
        for x in text:

            if x=='0':
                #Left child
                node = node.left

            elif x=='1':
                #Right child
                node = node.right

            else:
                print('Not Huffman encoded')

            #Leaf has type str
            if type(node)==str:
                decoded_str += node
                node = self.nodes[self.root_label]

        return decoded_str

def create_dict(text):
    '''
    Create the dictionary of characters with the number of occurrences.

    Args:
        text (str): Text from which you want to create the dictionary

    Returns:
        freq_dict (dict): Dictionary of couples (k, v), where:
                          k: character in the text
                          v: number of occurrences of v
    '''

    freq_dict = {}
    
    for x in text:
        if x in list(freq_dict.keys()):
            freq_dict[x] += 1
        else:
            freq_dict[x] = 1

    return freq_dict

def args_parser():
    '''
    Parser of command line arguments
    '''

    #Parser of command line arguments
    parser = argparse.ArgumentParser()
    #Initialization of needed arguments
    parser.add_argument("-file", "-f", dest="file", help="Path of the file to be encrypted")
    #Parse command line arguments
    args = parser.parse_args()
    
    return args.file

def main():
    file_path = args_parser()
    text = ''

    if file_path:
        if not(os.path.exists(file_path) and os.path.isfile(file_path)):
            print('[ERROR] File not found')

        with open(file_path, 'r') as f:
            text = f.read()
    else:
        text = sys.stdin.read()

    #Create the Huffman tree
    tree = HuffmanTree(create_dict(text))
    #Encode the text
    encoded_str = tree.encode(text)
    print(encoded_str)
    #Decode the text
    decoded_str = tree.decode(encoded_str)
    print(decoded_str)

if __name__=='__main__':
    main()